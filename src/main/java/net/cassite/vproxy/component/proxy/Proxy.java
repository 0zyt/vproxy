package net.cassite.vproxy.component.proxy;

import net.cassite.vproxy.connection.*;
import net.cassite.vproxy.protocol.ProtocolConnectionHandler;
import net.cassite.vproxy.protocol.ProtocolHandler;
import net.cassite.vproxy.protocol.ProtocolHandlerContext;
import net.cassite.vproxy.util.*;

import java.io.IOException;
import java.nio.channels.NetworkChannel;
import java.util.*;

/**
 * when a connection is accepted, another connection will be generated by calling the callback handler<br>
 * the accepted connection and the new connection form up a {@link Session}<br>
 * the session operations will always be handled in the same event loop
 */
public class Proxy {
    private static void utilCloseConnection(Connection connection) {
        assert Logger.lowLevelDebug("close connection " + connection);
        connection.close();
    }

    private static void utilCloseConnectionAndReleaseBuffers(Connection connection) {
        utilCloseConnection(connection);
        connection.getInBuffer().clean();
        connection.getOutBuffer().clean();
    }

    private static void utilCloseSessionAndReleaseBuffers(Session session) {
        utilCloseConnectionAndReleaseBuffers(session.active);
        utilCloseConnection(session.passive);
    }

    class SessionServerHandler implements ServerHandler {
        @Override
        public void acceptFail(ServerHandlerContext ctx, IOException err) {
            Logger.fatal(LogType.SERVER_ACCEPT_FAIL, "accept connection failed, server = " + config.server + ", err = " + err);
        }

        @Override
        public void connection(ServerHandlerContext ctx, Connection connection) {
            switch (config.connGen.type()) {
                case processor:
                    handleProcessor(connection);
                    break;
                case handler:
                    handleHandler(connection);
                    break;
                case direct:
                default:
                    handleDirect(connection);
            }
        }

        private void handleDirect(Connection connection) {
            // make connection to another end point
            Connector connector = config.connGen.genConnector(connection);
            handleDirect(connection, connector);
        }

        private void handleDirect(Connection connection, Connector connector) {
            // check whether address tuple is null
            // null means the user code fail to provide a new connection
            // maybe user think that the backend is not working, or the source ip is forbidden
            // any way, the user refuse to provide a new connection
            if (connector == null) {
                Logger.info(LogType.NO_CLIENT_CONN, "the user code refuse to provide a remote endpoint");
                // close the active connection
                utilCloseConnectionAndReleaseBuffers(connection);
                return;
            }

            ClientConnection clientConnection;
            try {
                clientConnection = connector.connect(
                    new ConnectionOpts().setTimeout(config.timeout),
                    /*switch the two buffers to make a PROXY*/connection.getOutBuffer(), connection.getInBuffer());
            } catch (IOException e) {
                Logger.fatal(LogType.CONN_ERROR, "make passive connection failed, maybe provided endpoint info is invalid", e);
                // it should not happen if user provided endpoint is valid
                // but if it happens, we close both sides

                utilCloseConnectionAndReleaseBuffers(connection);
                return;
            }

            Session session = new Session(connection, clientConnection);
            ClientConnectionHandler handler = new SessionClientConnectionHandler(session);

            // we get a new event loop for handling
            // the event loop is provided by user
            // user may use the same loop as the acceptLoop
            //
            // and we only register the passive connection here
            // the active connection will be registered
            // when the passive connection is successfully established
            NetEventLoop loop;
            {
                NetEventLoop foo = connector.loop();
                if (foo == null) {
                    assert Logger.lowLevelDebug("connector did not provide any loop, retrieve a new one");
                    loop = config.handleLoopProvider.get();
                } else {
                    assert Logger.lowLevelDebug("connector provided a loop");
                    loop = foo;
                }
            }
            if (loop == null) {
                // the loop not exist
                utilCloseSessionAndReleaseBuffers(session);
                Logger.warn(LogType.NO_EVENT_LOOP, "cannot get event loop for client connection " + clientConnection);
                return;
            }
            try {
                loop.addClientConnection(clientConnection, null, handler);

                // here the handler added successfully, we can record the session
                sessions.add(session);
                // the session record will be removed in `removed()` callback

            } catch (IOException e) {
                Logger.fatal(LogType.EVENT_LOOP_ADD_FAIL, "register passive connection into event loop failed, passive conn = " + clientConnection + ", err = " + e);
                // should not happen
                // but if it happens, we close both sides
                utilCloseSessionAndReleaseBuffers(session);
            }
        }

        class HandlerCallback extends Callback<Connector, IOException> {
            private final NetEventLoop loop;
            private final Connection active;

            HandlerCallback(NetEventLoop loop, Connection active) {
                this.loop = loop;
                this.active = active;
            }

            @Override
            protected void onSucceeded(Connector connector) {
                // remove the connection from loop first
                // because we want to remove the old ConnectionHandler
                // then handle it as direct
                try {
                    loop.removeConnection(active);
                } catch (Throwable t) {
                    // will raise error if it's not in the loop
                    // which should not happen
                    // but if happens, we close the connection
                    Logger.shouldNotHappen("remove the active connection from loop failed", t);
                    return;
                }
                // we don't care whether the connector is null or not
                // will be checked in the following method

                // handle like a normal proxy:
                handleDirect(active, connector);
            }

            @Override
            protected void onFailed(IOException err) {
                Logger.error(LogType.NO_CLIENT_CONN, "the user code got an exception", err);
                // we cannot handle the connection anymore
                // return an empty connector
                handleDirect(active, null);
            }
        }

        @SuppressWarnings(/*ignore generics here*/"unchecked")
        private void handleHandler(Connection connection) {
            // retrieve the handler
            ProtocolHandler pHandler = config.connGen.handler();
            // retrieve an event loop provided by user code
            // the net flow will be handled here
            NetEventLoop loop = config.handleLoopProvider.get();
            if (loop == null) {
                // the loop not exist
                Logger.warn(LogType.NO_EVENT_LOOP, "cannot get event loop for handler");
                connection.close();
                return;
            }

            // create a protocol context and init the handler
            ProtocolHandlerContext pctx = new ProtocolHandlerContext(connection.id(), connection, loop.getSelectorEventLoop(), pHandler);
            pHandler.init(pctx);

            // set callback
            Tuple<Object, Callback<Connector, IOException>> tup = (Tuple) pctx.data;
            if (tup == null) {
                // user code fail to provide the data
                Logger.error(LogType.IMPROPER_USE, "user code should set a tuple(T, null) to the data field");
                // close the connection because we cannot handle it anymore
                connection.close();
                return;
            }
            tup = new Tuple<>(tup.left, new HandlerCallback(loop, connection));
            pctx.data = tup;

            // the following code should be same as in ProtocolServerHandler
            //noinspection Duplicates
            try {
                loop.addConnection(connection, pHandler, new ProtocolConnectionHandler(pctx));
            } catch (IOException e) {
                // handle exception in handler
                pHandler.exception(pctx, e);
                // and do some log
                Logger.error(LogType.EVENT_LOOP_ADD_FAIL, "add new connection into loop failed", e);
                // the connection should be closed by the lib
                connection.close();
            }
        }

        @SuppressWarnings("unchecked")
        private void handleProcessor(Connection frontendConnection) {
            Processor processor = config.connGen.processor();
            Processor.Context topCtx = processor.init();
            Processor.SubContext frontendSubCtx = processor.initSub(topCtx, 0);
            {
                byte[] data = processor.connected(topCtx, frontendSubCtx);
                assert data == null || data.length == 0; // nothing should be directly written to the frontend
            }

            // retrieve an event loop
            NetEventLoop loop = config.handleLoopProvider.get();

            // ------------------------------
            // --- START frontend handler ---
            ConnectionHandler handler = new ConnectionHandler() {
                Map<BackendConnectionHandler, Integer> conn2intMap = new HashMap<>();
                int cursor = 0;
                BackendConnectionHandler[] conns = new BackendConnectionHandler[1024 + 1];
                // [0] will not be used
                // I believe that 1024 connections should be enough

                ByteArrayChannel chnl = null;

                void recordBackend(BackendConnectionHandler backend, int connId) {
                    conn2intMap.put(backend, connId);
                    conns[connId] = backend;
                }

                void removeBackend(BackendConnectionHandler backend) {
                    int connId = conn2intMap.remove(backend);
                    conns[connId] = null;
                }

                /**
                 * a util function. NOTE: this method should be called in a while loop until no data to send or buffer is full
                 * @param flow the target flow
                 * @param sourceConnection source connection when proxying
                 * @param targetConnection target connection when proxying
                 * @param subCtx sub context of the source connection
                 */
                void utilWriteData(BackendConnectionHandler.ByteFlow flow,
                                   Connection sourceConnection,
                                   Connection targetConnection,
                                   Processor.SubContext subCtx) {
                    assert Logger.lowLevelDebug("calling utilWriteData, writing from " + sourceConnection + " to " + targetConnection);

                    if (flow.runningProxy) {
                        assert Logger.lowLevelDebug("running proxy, flow.bytesToProxy = " + flow.bytesToProxy);
                        if (flow.bytesToProxy == 0) {
                            // nothing to write
                            return;
                        }
                        int n = sourceConnection.getInBuffer()
                            .writeTo(targetConnection.getOutBuffer(), flow.bytesToProxy);
                        flow.bytesToProxy -= n;
                        assert Logger.lowLevelDebug("proxied " + n + " bytes, still have " + flow.bytesToProxy + " left");
                        assert flow.bytesToProxy >= 0;
                        // proxy is done
                        if (flow.bytesToProxy == 0) {
                            assert Logger.lowLevelDebug("proxy done");
                            flow.runningProxy = false;
                            processor.proxyDone(topCtx, subCtx);
                        }
                    } else {
                        assert Logger.lowLevelDebug("sending bytes, flow.chnl.used = " + (flow.chnl == null ? "null" : flow.chnl.used()));
                        if (flow.chnl == null) {
                            if (flow.bytesToSend.isEmpty()) {
                                // nothing to write
                                return;
                            }
                            byte[] data = flow.bytesToSend.peek(); // do not remove from list for now <--#1
                            flow.chnl = ByteArrayChannel.fromFull(data);
                            assert Logger.lowLevelDebug("peek data from list, the length is " + data.length);
                        }
                        targetConnection.getOutBuffer().storeBytesFrom(flow.chnl);
                        // sending this batch is done
                        assert flow.chnl != null;
                        assert Logger.lowLevelDebug("now flow.chnl.used == " + flow.chnl.used());
                        if (flow.chnl.used() == 0) {
                            flow.chnl = null;
                            flow.bytesToSend.poll(); // remove from list when done <--#1
                            if (flow.bytesToSend.isEmpty()) {
                                flow.runningProxy = true;
                            }
                        }
                    }
                }

                // -----------------------------
                // --- START backend handler ---
                class BackendConnectionHandler implements ClientConnectionHandler {
                    class ByteFlow {
                        boolean runningProxy = false; // false = bytes, true = proxy
                        ByteArrayChannel chnl = null;
                        // NOTE: chnl always hold data of the first element in the list
                        // and the list will only be poped when all data is sent in this chnl
                        final LinkedList<byte[]> bytesToSend = new LinkedList<>();
                        int bytesToProxy = 0;
                        // the bytesToSend list may be added the same time the data in the list is sent
                        // but when handling bytesToProxy, there will be no data adding to the bytesToSend list
                        // until the proxy is done
                        // This is because that the processor fetch data out from buffer and process them,
                        // then add the processed data to the bytesToSend list.
                        // However for the proxy operation, data will be directly proxied from
                        // input buffer of connection A to output buffer of connection B.
                        // Because of this, the `runningProxy` field is enough for the lib to know current running mode.
                        // Still, when writing a Processor, keep this behavior in mind and
                        // don't change mode from proxy to another until `proxyDone()` is called.

                        void write(byte[] data) {
                            bytesToSend.add(data);
                            if (bytesToProxy == 0) {
                                runningProxy = false;
                            }
                        }

                        void proxy(int len) {
                            if (bytesToProxy == 0) {
                                bytesToProxy = len;
                            }
                            if (bytesToSend.isEmpty()) {
                                runningProxy = true;
                            }
                        }
                    }

                    private final Processor.SubContext subCtx;
                    private final ClientConnection conn;
                    private boolean isConnected = false;

                    private ByteArrayChannel chnl = null;
                    private final ByteFlow backendByteFlow = new ByteFlow();
                    private final ByteFlow frontendByteFlow = new ByteFlow();

                    BackendConnectionHandler(Processor.SubContext subCtx, ClientConnection conn) {
                        this.subCtx = subCtx;
                        this.conn = conn;
                    }

                    void writeToBackend(byte[] data) {
                        backendByteFlow.write(data);
                        doBackendWrite();
                    }

                    void proxyToBackend(int len) {
                        backendByteFlow.proxy(len);
                        doBackendWrite();
                    }

                    void writeToFrontend(byte[] data) {
                        frontendByteFlow.write(data);
                        frontendWrite(this);
                    }

                    void proxyToFrontend(int len) {
                        frontendByteFlow.proxy(len);
                        frontendWrite(this);
                    }

                    private boolean isWritingBackend = false;

                    /**
                     * write data from {@link #backendByteFlow} to backend connection
                     */
                    private void doBackendWrite() {
                        if (!isConnected) {
                            return; // do nothing if not connected yet
                        }
                        if (isWritingBackend) {
                            assert Logger.lowLevelDebug("isWritingBackend exit the method");
                            return; // it's already writing, should not call again
                        }
                        isWritingBackend = true;
                        while (backendByteFlow.bytesToProxy != 0 || !backendByteFlow.bytesToSend.isEmpty()) {
                            if (conn.getOutBuffer().free() == 0) {
                                // if the output is full, should break the writing process and wait for the next signal
                                assert Logger.lowLevelDebug("the backend output buffer is full now, break the sending loop");
                                break;
                            }
                            // if it's running proxy and the frontend connection input is empty, break the loop
                            if (backendByteFlow.runningProxy && frontendConnection.getInBuffer().used() == 0) {
                                break;
                            }

                            utilWriteData(backendByteFlow, frontendConnection, conn, frontendSubCtx);
                        }
                        isWritingBackend = false; // writing done
                        // if writing is done
                        if (backendByteFlow.bytesToProxy == 0 && backendByteFlow.bytesToSend.isEmpty()) {
                            // let the frontend read more data because there may still have some data in buffer
                            readFrontend();
                        }
                    }

                    @Override
                    public void connected(ClientConnectionHandlerContext ctx) {
                        isConnected = true;
                        // no need to call processor.connected(...) here, it's already called when retrieving the connection
                        doBackendWrite();
                    }

                    void readBackend() {
                        if (conn.getInBuffer().used() == 0)
                            return; // ignore the event if got nothing to read

                        assert Logger.lowLevelDebug("calling readBackend() of " + conn);

                        // check whether to proxy the data or to receive the data
                        Processor.Mode mode = processor.mode(topCtx, subCtx);
                        assert Logger.lowLevelDebug("the current mode is " + mode);

                        if (mode == Processor.Mode.proxy) {
                            int len = processor.len(topCtx, subCtx);
                            assert Logger.lowLevelDebug("the proxy length is " + len);
                            if (len == 0) { // 0 bytes to proxy, so it's already done
                                processor.proxyDone(topCtx, subCtx);
                                readBackend(); // recursively call to handle more input data
                            } else {
                                proxyToFrontend(len);
                            }
                        } else {
                            if (chnl == null) {
                                int len = processor.len(topCtx, subCtx);
                                assert Logger.lowLevelDebug("the expected message length is " + len);
                                if (len == 0) { // if nothing to read, then directly feed empty data to the processor
                                    try {
                                        processor.feed(topCtx, subCtx, new byte[0]);
                                    } catch (Exception e) {
                                        Logger.warn(LogType.INVALID_EXTERNAL_DATA, "user code cannot handle data from " + conn + ", which corresponds to " + frontendConnection + ". err=" + e);
                                        frontendConnection.close();
                                        return;
                                    }
                                    readBackend(); // recursively handle more data
                                    return;
                                }
                                chnl = ByteArrayChannel.fromEmpty(new byte[len]);
                            }
                            conn.getInBuffer().writeTo(chnl);
                            if (chnl.free() != 0) {
                                assert Logger.lowLevelDebug("not fulfilled yet, expecting " + chnl.free() + " length of data");
                                // expecting more data
                                return;
                            }
                            assert Logger.lowLevelDebug("the message is totally read, feeding to processor");
                            byte[] data = chnl.get();
                            chnl = null;
                            byte[] dataToSend;
                            try {
                                dataToSend = processor.feed(topCtx, subCtx, data);
                            } catch (Exception e) {
                                Logger.warn(LogType.INVALID_EXTERNAL_DATA, "user code cannot handle data from " + conn + ", which corresponds to " + frontendConnection + ". err=" + e);
                                frontendConnection.close();
                                return;
                            }
                            assert Logger.lowLevelDebug("the processor return a message of length " + (dataToSend == null ? "null" : dataToSend.length));
                            if (dataToSend == null || dataToSend.length == 0) {
                                readBackend(); // recursively call to handle more data
                            } else {
                                writeToFrontend(dataToSend);
                            }
                        }
                    }

                    @Override
                    public void readable(ConnectionHandlerContext ctx) {
                        readBackend();
                    }

                    @Override
                    public void writable(ConnectionHandlerContext ctx) {
                        doBackendWrite();
                    }

                    @Override
                    public void exception(ConnectionHandlerContext ctx, IOException err) {
                        Logger.error(LogType.CONN_ERROR, "got exception when handling backend connection " + conn + ", closing frontend " + frontendConnection);
                        frontendConnection.close();
                    }

                    @Override
                    public void closed(ConnectionHandlerContext ctx) {
                        if (frontendConnection.isClosed()) {
                            assert Logger.lowLevelDebug("backend connection " + ctx.connection + " closed, corresponding frontend is " + frontendConnection);
                        } else {
                            Logger.warn(LogType.CONN_ERROR, "backend connection " + ctx.connection + " closed before frontend connection " + frontendConnection);
                        }
                        removeBackend(this);
                        frontendConnection.close();
                    }

                    @Override
                    public void removed(ConnectionHandlerContext ctx) {
                        if (!ctx.connection.isClosed())
                            Logger.error(LogType.IMPROPER_USE, "backend connection " + ctx.connection + " removed from event loop " + loop);
                        frontendConnection.close();
                    }
                }
                // --- END backend handler ---
                // ---------------------------

                private BackendConnectionHandler handlingConnection;

                void frontendWrite(BackendConnectionHandler handlingConnection) {
                    if (this.handlingConnection == null) {
                        this.handlingConnection = handlingConnection;
                    }
                    if (this.handlingConnection == handlingConnection) {
                        doFrontendWrite();
                    }
                }

                private boolean isWritingFrontend = false;

                private void doFrontendWrite() {
                    if (isWritingFrontend) {
                        assert Logger.lowLevelDebug("isWritingFrontend exit the method");
                        return; // should exit because it's already handling
                        // this might happen when the frontend connection output buffer calls writable()
                        // here is already a loop in the _doFrontendWrite(), so we just exit the method when it's already handling
                    }
                    isWritingFrontend = true;
                    _doFrontendWrite();
                    isWritingFrontend = false;
                }

                private void _doFrontendWrite() {
                    if (handlingConnection == null) {
                        return; // nothing to write
                    }
                    {
                        BackendConnectionHandler.ByteFlow flow = handlingConnection.frontendByteFlow;
                        while (flow.bytesToProxy != 0 || !flow.bytesToSend.isEmpty()) {
                            if (frontendConnection.getOutBuffer().free() == 0) {
                                return; // end the method, because the out buffer has no space left
                            }

                            utilWriteData(flow, handlingConnection.conn, frontendConnection, handlingConnection.subCtx);

                            // if writing done:
                            if (flow.bytesToProxy == 0 && flow.bytesToSend.isEmpty()) {
                                // then let the backend connection read more data
                                // because the connection may be holding some data in the buffer
                                handlingConnection.readBackend();
                            } else { // writing not done yet,
                                // but if it's running proxy and the backend connection input buffer is empty
                                if (flow.runningProxy && handlingConnection.conn.getInBuffer().used() == 0) {
                                    return; // cannot handle for now, end the method
                                }
                            }
                        }
                        // now nothing to be handled for this connection
                        handlingConnection = null;
                    }

                    // check for other connections
                    // and keep writing if have some data to write in other connections
                    {
                        BackendConnectionHandler next = null;
                        for (BackendConnectionHandler b : conn2intMap.keySet()) {
                            BackendConnectionHandler.ByteFlow flow = b.frontendByteFlow;
                            if (flow.bytesToProxy != 0 || !flow.bytesToSend.isEmpty()) {
                                next = b;
                                break;
                            }
                        }
                        handlingConnection = next;
                        doFrontendWrite();
                    }
                }

                void readFrontend() {
                    if (frontendConnection.getInBuffer().used() == 0) {
                        return; // do nothing if the in buffer is empty
                    }

                    assert Logger.lowLevelDebug("calling readFrontend()");

                    // check whether to proxy the data or to receive the data
                    Processor.Mode mode = processor.mode(topCtx, frontendSubCtx);
                    assert Logger.lowLevelDebug("the current mode is " + mode);

                    if (mode == Processor.Mode.proxy) {
                        int bytesToProxy = processor.len(topCtx, frontendSubCtx);
                        int connId = processor.connection(topCtx, frontendSubCtx);
                        assert Logger.lowLevelDebug("the bytesToProxy is " + bytesToProxy + ", and connId is " + connId);
                        BackendConnectionHandler backend = getConnection(connId);
                        if (backend == null) {
                            // for now, we simply close the whole connection when a backend is missing
                            Logger.error(LogType.CONN_ERROR, "failed to retrieve the backend connection for " + frontendConnection + "/" + connId);
                            frontendConnection.close();
                        } else {
                            if (bytesToProxy == 0) { // 0 bytes to proxy, so it's already done
                                processor.proxyDone(topCtx, frontendSubCtx);
                                readFrontend(); // recursively call to read more data
                            } else {
                                backend.proxyToBackend(bytesToProxy);
                            }
                        }
                    } else {
                        assert mode == Processor.Mode.handle;

                        if (chnl == null) {
                            int len = processor.len(topCtx, frontendSubCtx);
                            assert Logger.lowLevelDebug("expecting message with the length of " + len);
                            if (len == 0) { // if the length is 0, directly feed data to the processor
                                try {
                                    processor.feed(topCtx, frontendSubCtx, new byte[0]);
                                } catch (Exception e) {
                                    Logger.warn(LogType.INVALID_EXTERNAL_DATA, "user code cannot handle data from " + frontendConnection + ". err=" + e);
                                    frontendConnection.close();
                                    return;
                                }
                                readFrontend(); // recursively try to handle more data
                                return;
                            }
                            chnl = ByteArrayChannel.fromEmpty(new byte[len]);
                        }
                        frontendConnection.getInBuffer().writeTo(chnl);
                        if (chnl.free() != 0) {
                            // want to read more data
                            assert Logger.lowLevelDebug("not fulfilled yet, waiting for data of length " + chnl.free());
                            return;
                        }
                        assert Logger.lowLevelDebug("data reading is done now");
                        byte[] data = chnl.get();
                        chnl = null;
                        // handle the data
                        byte[] bytesToSend;
                        try {
                            bytesToSend = processor.feed(topCtx, frontendSubCtx, data);
                        } catch (Exception e) {
                            Logger.warn(LogType.INVALID_EXTERNAL_DATA, "user code cannot handle data from " + frontendConnection + ". err=" + e);
                            frontendConnection.close();
                            return;
                        }

                        int connId = processor.connection(topCtx, frontendSubCtx);
                        assert Logger.lowLevelDebug("the processor return data of length " + (bytesToSend == null ? "null" : bytesToSend.length) + ", sending to connId=" + connId);
                        BackendConnectionHandler backend = getConnection(connId);
                        if (backend == null) {
                            // for now, we simply close the whole connection when a backend is missing
                            Logger.error(LogType.CONN_ERROR, "failed to retrieve the backend connection for " + frontendConnection + "/" + connId);
                            frontendConnection.close();
                        } else {
                            if (bytesToSend == null || bytesToSend.length == 0) {
                                readFrontend(); // recursively call to handle more data
                            } else {
                                backend.writeToBackend(bytesToSend);
                            }
                        }
                    }
                }

                @Override
                public void readable(ConnectionHandlerContext ctx) {
                    readFrontend();
                }

                private BackendConnectionHandler getConnection(int connId) {
                    if (connId > 0 && conns[connId] != null)
                        return conns[connId]; // get connection if it already exists

                    assert connId == -1;

                    // get connector
                    Connector connector = config.connGen.genConnector(frontendConnection);
                    if (connector == null) {
                        Logger.info(LogType.NO_CLIENT_CONN, "the user code refuse to provide a remote endpoint");
                        return null;
                    }
                    if (connector.loop() != null) {
                        Logger.error(LogType.IMPROPER_USE, "it's not supported to specify event loop when running processors");
                        return null;
                    }

                    // find a connection if possible
                    for (int existingConnId : conn2intMap.values()) {
                        if (conns[existingConnId].conn.remote.equals(connector.remote)) {
                            BackendConnectionHandler bh = conns[existingConnId];
                            processor.chosen(topCtx, frontendSubCtx, bh.subCtx);
                            return bh;
                        }
                    }

                    // get a new connection
                    ClientConnection clientConnection;
                    try {
                        clientConnection = connector.connect(
                            new ConnectionOpts().setTimeout(config.timeout),
                            RingBuffer.allocateDirect(config.inBufferSize), RingBuffer.allocateDirect(config.outBufferSize));
                    } catch (IOException e) {
                        Logger.fatal(LogType.CONN_ERROR, "make passive connection failed, maybe provided endpoint info is invalid", e);
                        return null;
                    }

                    // record in collections
                    int newConnId = ++cursor;
                    BackendConnectionHandler bh =
                        new BackendConnectionHandler(processor.initSub(topCtx, newConnId), clientConnection);
                    recordBackend(bh, newConnId);
                    // register
                    try {
                        loop.addClientConnection(clientConnection, null, bh);
                    } catch (IOException e) {
                        Logger.fatal(LogType.EVENT_LOOP_ADD_FAIL, "add client connection " + clientConnection + " to loop failed");

                        // remove from collection because it fails
                        removeBackend(bh);
                        clientConnection.close();

                        return null;
                    }

                    byte[] bytes = processor.connected(topCtx, bh.subCtx);
                    processor.chosen(topCtx, frontendSubCtx, bh.subCtx);

                    if (bytes != null && bytes.length > 0) {
                        bh.writeToBackend(bytes);
                    }

                    return bh;
                }

                @Override
                public void writable(ConnectionHandlerContext ctx) {
                    doFrontendWrite();
                }

                @Override
                public void exception(ConnectionHandlerContext ctx, IOException err) {
                    Logger.error(LogType.CONN_ERROR, "connection got exception", err);
                    frontendConnection.close();
                    // we will close connections to backend in closed callback
                }

                @Override
                public void closed(ConnectionHandlerContext ctx) {
                    assert Logger.lowLevelDebug("frontend connection is closed: " + frontendConnection);
                    List<Integer> ints = new ArrayList<>(conn2intMap.values());
                    for (int i : ints) {
                        BackendConnectionHandler be = conns[i];
                        removeBackend(be);
                        be.conn.close();
                    }
                }

                @Override
                public void removed(ConnectionHandlerContext ctx) {
                    if (!frontendConnection.isClosed())
                        Logger.error(LogType.IMPROPER_USE, "frontend connection " + frontendConnection + " removed from event loop " + loop);
                    frontendConnection.close();
                }
            };
            // --- END frontend handler ---
            // ----------------------------
            try {
                loop.addConnection(frontendConnection, null, handler);
            } catch (IOException e) {
                // and do some log
                Logger.error(LogType.EVENT_LOOP_ADD_FAIL, "add new connection into loop failed", e);
                // the connection should be closed by the lib
                frontendConnection.close();
            }
        }

        @Override
        public Tuple<RingBuffer, RingBuffer> getIOBuffers(NetworkChannel channel) {
            RingBuffer inBuffer = RingBuffer.allocateDirect(config.inBufferSize);
            RingBuffer outBuffer = RingBuffer.allocateDirect(config.outBufferSize);
            return new Tuple<>(inBuffer, outBuffer);
        }

        @Override
        public void removed(ServerHandlerContext ctx) {
            handler.serverRemoved(ctx.server);
        }

        @Override
        public ConnectionOpts connectionOpts() {
            return new ConnectionOpts().setTimeout(config.timeout);
        }
    }

    class SessionConnectionHandler implements ConnectionHandler {
        private final Session session;

        SessionConnectionHandler(Session session) {
            this.session = session;
        }

        @Override
        public void readable(ConnectionHandlerContext ctx) {
            // the input buffer is attached to remote write buffer
            // and output buffer is attached to remote read buffer
            // as a result,
            // the write and read process is automatically handled by the lib
        }

        @Override
        public void writable(ConnectionHandlerContext ctx) {
            // we might write the last bytes here
            // when we write everything, we close the connection
            if (session.passive.isClosed() && ctx.connection.getOutBuffer().used() == 0)
                utilCloseConnectionAndReleaseBuffers(ctx.connection);
        }

        @Override
        public void exception(ConnectionHandlerContext ctx, IOException err) {
            if (Utils.isReset(err)) {
                assert Logger.lowLevelDebug("session " + session + " got exception: " + err);
            } else {
                Logger.error(LogType.CONN_ERROR, "session " + session + " got exception: " + err);
            }
            // close both sides
            utilCloseSessionAndReleaseBuffers(session);
        }

        @Override
        public void closed(ConnectionHandlerContext ctx) {
            assert Logger.lowLevelDebug("now the connection is closed, we should close the session");
            // now the active connection is closed
            if (session.isClosed()) // do nothing if the session is already closed
                return;
            if (session.passive.getOutBuffer().used() == 0) {
                // nothing to write anymore
                // close the passive connection
                assert Logger.lowLevelDebug("nothing to write for passive connection, do close");
                utilCloseConnectionAndReleaseBuffers(session.passive);
            } else {
                assert Logger.lowLevelDebug("we should close the passive connection after everything wrote");
                // and we close the active conn's output buffer, i.e. passive's input buffer
                // then the passive will not be able to write anything to active

                // the passive can still read from the active conn's in-buffer if still got some bytes
                session.passive.getInBuffer().close();
            }
        }

        @Override
        public void removed(ConnectionHandlerContext ctx) {
            utilCloseSessionAndReleaseBuffers(session);
        }
    }

    class SessionClientConnectionHandler implements ClientConnectionHandler {
        private final Session session;
        private boolean isConnected = false;

        SessionClientConnectionHandler(Session session) {
            this.session = session;
        }

        @Override
        public void connected(ClientConnectionHandlerContext ctx) {
            assert Logger.lowLevelDebug("passive connection established: " + ctx.connection);
            isConnected = true; // it's connected

            // now we can add active connection into event loop
            // use event loop from context
            // the active and passive connection are handled in the same loop
            try {
                ctx.eventLoop.addConnection(session.active, null, new SessionConnectionHandler(session));
            } catch (IOException e) {
                Logger.fatal(LogType.EVENT_LOOP_ADD_FAIL, "register active connection into event loop failed, conn = " + session.active + ", err = " + e);
                // add into event loop failed
                // close session
                assert Logger.lowLevelDebug("nothing to write for active connection, do close");
                utilCloseSessionAndReleaseBuffers(session);
            }
        }

        @Override
        public void readable(ConnectionHandlerContext ctx) {
            // see readable in SessionConnectHandler#readable
        }

        @Override
        public void writable(ConnectionHandlerContext ctx) {
            // we might write the last bytes here
            // when we write everyhing, we close the connection
            if (session.active.isClosed() && ctx.connection.getOutBuffer().used() == 0)
                utilCloseConnectionAndReleaseBuffers(ctx.connection);
        }

        @Override
        public void exception(ConnectionHandlerContext ctx, IOException err) {
            Logger.error(LogType.CONN_ERROR, "session " + session + " got exception: " + err);
            // close both sides
            utilCloseSessionAndReleaseBuffers(session);

            if (!isConnected) {
                // the connection failed before established
                // we should alert the connector that the connection failed
                Connector connector = ((ClientConnection) ctx.connection).getConnector();
                if (connector != null) {
                    connector.connectionFailed();
                }
            }
        }

        @Override
        public void closed(ConnectionHandlerContext ctx) {
            assert Logger.lowLevelDebug("now the passive connection is closed, we should close the session");
            // now the passive connection is closed
            if (session.isClosed()) // do nothing if the session is already closed
                return;
            if (session.active.getOutBuffer().used() == 0) {
                // nothing to write anymore
                // close the active connection
                utilCloseConnectionAndReleaseBuffers(session.active);
            } else {
                assert Logger.lowLevelDebug("we should close the active connection after everything wrote");
                // and we close the passive conn's output buffer, i.e. active's input buffer
                // then the active will not be able to write anything to passive

                // the active can still read from the passive conn's in-buffer if still got some bytes
                session.active.getInBuffer().close();
            }
        }

        @Override
        public void removed(ConnectionHandlerContext ctx) {
            utilCloseSessionAndReleaseBuffers(session);
            sessions.remove(session); // remove the session record
        }
    }

    public final ProxyNetConfig config;
    private final ProxyEventHandler handler;
    private final ConcurrentHashSet<Session> sessions = new ConcurrentHashSet<>();

    public Proxy(ProxyNetConfig config, ProxyEventHandler handler) {
        this.handler = handler;
        this.config = config;
    }

    public void handle() throws IOException {
        config.acceptLoop.addServer(config.server, null, new SessionServerHandler());
    }

    public void stop() {
        config.acceptLoop.removeServer(config.server);
    }

    public int sessionCount() {
        return sessions.size();
    }

    public void copySessions(Collection<? super Session> coll) {
        coll.addAll(sessions);
    }
}
